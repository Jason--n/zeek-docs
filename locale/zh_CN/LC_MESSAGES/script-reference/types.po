# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, The Zeek Project
# This file is distributed under the same license as the Zeek package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Zeek source\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-28 21:33+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../script-reference/types.rst:2
msgid "Types"
msgstr ""

#: ../../script-reference/types.rst:4
msgid "The Zeek scripting language supports the following built-in types:"
msgstr ""

#: ../../script-reference/types.rst:7
msgid "Name"
msgstr ""

#: ../../script-reference/types.rst:7
msgid "Description"
msgstr ""

#: ../../script-reference/types.rst:9
msgid ":zeek:type:`bool`"
msgstr ""

#: ../../script-reference/types.rst:9
msgid "Boolean"
msgstr ""

#: ../../script-reference/types.rst:11
msgid ":zeek:type:`count`, :zeek:type:`int`, :zeek:type:`double`"
msgstr ""

#: ../../script-reference/types.rst:11
msgid "Numeric types"
msgstr ""

#: ../../script-reference/types.rst:15
msgid ":zeek:type:`time`, :zeek:type:`interval`"
msgstr ""

#: ../../script-reference/types.rst:15
msgid "Time types"
msgstr ""

#: ../../script-reference/types.rst:18
msgid ":zeek:type:`string`"
msgstr ""

#: ../../script-reference/types.rst:18
msgid "String"
msgstr ""

#: ../../script-reference/types.rst:20
msgid ":zeek:type:`pattern`"
msgstr ""

#: ../../script-reference/types.rst:20
msgid "Regular expression"
msgstr ""

#: ../../script-reference/types.rst:22
msgid ":zeek:type:`port`, :zeek:type:`addr`, :zeek:type:`subnet`"
msgstr ""

#: ../../script-reference/types.rst:22
msgid "Network types"
msgstr ""

#: ../../script-reference/types.rst:26
msgid ":zeek:type:`enum`"
msgstr ""

#: ../../script-reference/types.rst:26
msgid "Enumeration (user-defined type)"
msgstr ""

#: ../../script-reference/types.rst:29
msgid ""
":zeek:type:`table`, :zeek:type:`set`, :zeek:type:`vector`, "
":zeek:type:`record`"
msgstr ""

#: ../../script-reference/types.rst:29
msgid "Container types"
msgstr ""

#: ../../script-reference/types.rst:34
msgid ":zeek:type:`function`, :zeek:type:`event`, :zeek:type:`hook`"
msgstr ""

#: ../../script-reference/types.rst:34
msgid "Executable types"
msgstr ""

#: ../../script-reference/types.rst:38
msgid ":zeek:type:`file`"
msgstr ""

#: ../../script-reference/types.rst:38
msgid "File type (only for writing)"
msgstr ""

#: ../../script-reference/types.rst:41
msgid ":zeek:type:`opaque`"
msgstr ""

#: ../../script-reference/types.rst:41
msgid "Opaque type (for some built-in functions)"
msgstr ""

#: ../../script-reference/types.rst:45
msgid ":zeek:type:`any`"
msgstr ""

#: ../../script-reference/types.rst:45
msgid "Any type (for functions or containers)"
msgstr ""

#: ../../script-reference/types.rst:50
msgid "Here is a more detailed description of each type:"
msgstr ""

#: ../../script-reference/types.rst:56
msgid "bool"
msgstr ""

#: ../../script-reference/types.rst:58
msgid ""
"Reflects a value with one of two meanings: true or false.  The two "
"``bool`` constants are ``T`` and ``F``."
msgstr ""

#: ../../script-reference/types.rst:61
msgid ""
"The ``bool`` type supports the following operators: equality/inequality "
"(``==``, ``!=``), logical and/or (``&&``, ``||``), logical negation "
"(``!``), and absolute value (where ``|T|`` is ``1``, and ``|F|`` is "
"``0``, and in both cases the result type is :zeek:type:`count`)."
msgstr ""

#: ../../script-reference/types.rst:70
msgid "int"
msgstr ""

#: ../../script-reference/types.rst:72
msgid ""
"A numeric type representing a 64-bit signed integer.  An ``int`` constant"
" is a string of digits preceded by a ``+`` or ``-`` sign, e.g. ``-42`` or"
" ``+5`` (the ``+`` sign is optional but see note about type inferencing "
"below).  An ``int`` constant can also be written in hexadecimal notation "
"(in which case ``0x`` must be between the sign and the hex digits), e.g. "
"``-0xFF`` or ``+0xabc123``."
msgstr ""

#: ../../script-reference/types.rst:79
msgid ""
"The ``int`` type supports the following operators:  arithmetic operators "
"(``+``, ``-``, ``*``, ``/``, ``%``), comparison operators (``==``, "
"``!=``, ``<``, ``<=``, ``>``, ``>=``), assignment operators (``=``, "
"``+=``, ``-=``), pre-increment (``++``), pre-decrement (``--``), unary "
"plus and minus (``+``, ``-``), and absolute value (e.g., ``|-3|`` is 3, "
"but the result type is :zeek:type:`count`)."
msgstr ""

#: ../../script-reference/types.rst:86
msgid ""
"When using type inferencing, use care so that the intended type is "
"inferred, e.g. ``local size_difference = 0`` will infer "
":zeek:type:`count`, while ``local size_difference = +0`` will infer "
"``int``."
msgstr ""

#: ../../script-reference/types.rst:91
msgid ""
"For signed-integer arithmetic involving ``int`` types that cause "
"overflows (results that exceed the numeric limits of representable values"
" in either direction), Zeek's behavior is generally undefined  and one "
"should not rely on any observed behavior being consistent across "
"compilers, platforms, time, etc. The reason for this is that the C++ "
"standard also deems this as undefined behavior and Zeek does not "
"currently attempt to detect such overflows within its underlying C++ "
"implementation (some limited cases may try to statically determine at "
"parse-time that an overflow will definitely occur and reject them an "
"error, but don't rely on that)."
msgstr ""

#: ../../script-reference/types.rst:104
msgid "count"
msgstr ""

#: ../../script-reference/types.rst:106
msgid ""
"A numeric type representing a 64-bit unsigned integer.  A ``count`` "
"constant is a string of digits, e.g. ``1234`` or ``0``.  A ``count`` can "
"also be written in hexadecimal notation (in which case ``0x`` must "
"precede the hex digits), e.g. ``0xff`` or ``0xABC123``."
msgstr ""

#: ../../script-reference/types.rst:111
msgid ""
"The ``count`` type supports the same operators as the :zeek:type:`int` "
"type, but a unary plus or minus applied to a ``count`` results in an "
":zeek:type:`int`."
msgstr ""

#: ../../script-reference/types.rst:115
msgid ""
"In addition, ``count`` types support bitwise operations.  You can use "
"``&``, ``|``, and ``^`` for bitwise ``and``, ``or``, and ``xor``.  You "
"can also use ``~`` for bitwise (one's) complement."
msgstr ""

#: ../../script-reference/types.rst:119
msgid ""
"For unsigned arithmetic involving ``count`` types that cause overflows "
"(results that exceed the numeric limits of representable value in either "
"direction), Zeek's behavior is to wrap the result modulo 2^64 back into "
"the range of representable values (the same behavior as defined by C++)."
msgstr ""

#: ../../script-reference/types.rst:126
msgid ""
"Integer literals in Zeek that are not preceded by a unary ``+`` or ``-`` "
"are treated as the unsigned ``count`` type.  This can cause unintentional"
" surprises is some situations, like for an absolute-value operation of "
"``|5 - 9|`` that results in an unsigned-integer overflow to the large "
"number of ``18446744073709551612`` where ``|+5 - +9|`` results in signed-"
"integer arithmetic and (likely) more expected result of ``4``."
msgstr ""

#: ../../script-reference/types.rst:136
msgid "double"
msgstr ""

#: ../../script-reference/types.rst:138
msgid ""
"A numeric type representing a double-precision floating-point number.  "
"Floating-point constants are written as a string of digits with an "
"optional decimal point, optional scale-factor in scientific notation, and"
" optional ``+`` or ``-`` sign.  Examples are ``-1234``, ``-1234e0``, "
"``3.14159``, and ``.003E-23``."
msgstr ""

#: ../../script-reference/types.rst:144
msgid ""
"The ``double`` type supports the following operators:  arithmetic "
"operators (``+``, ``-``, ``*``, ``/``), comparison operators (``==``, "
"``!=``, ``<``, ``<=``, ``>``, ``>=``), assignment operators (``=``, "
"``+=``, ``-=``), unary plus and minus (``+``, ``-``), and absolute value "
"(e.g., ``|-3.14|`` is 3.14)."
msgstr ""

#: ../../script-reference/types.rst:150
msgid ""
"When using type inferencing use care so that the intended type is "
"inferred, e.g. ``local size_difference = 5`` will infer "
":zeek:type:`count`, while ``local size_difference = 5.0`` will infer "
"``double``."
msgstr ""

#: ../../script-reference/types.rst:159
msgid "time"
msgstr ""

#: ../../script-reference/types.rst:161
msgid ""
"A temporal type representing an absolute time.  There is currently no way"
" to specify a ``time`` constant, but one can use the "
":zeek:id:`double_to_time`, :zeek:id:`current_time`, or "
":zeek:id:`network_time` built-in functions to assign a value to a "
"``time``-typed variable."
msgstr ""

#: ../../script-reference/types.rst:166
msgid ""
"Time values support the comparison operators (``==``, ``!=``, ``<``, "
"``<=``, ``>``, ``>=``).  A ``time`` value can be subtracted from another "
"``time`` value to produce an :zeek:type:`interval` value.  An "
"``interval`` value can be added to, or subtracted from, a ``time`` value "
"to produce a ``time`` value.  The absolute value of a ``time`` value is a"
" :zeek:type:`double` with the same numeric value."
msgstr ""

#: ../../script-reference/types.rst:177
msgid "interval"
msgstr ""

#: ../../script-reference/types.rst:179
msgid ""
"A temporal type representing a relative time.  An ``interval`` constant "
"can be written as a numeric constant followed by a time unit where the "
"time unit is one of ``usec``, ``msec``, ``sec``, ``min``, ``hr``, or "
"``day`` which respectively represent microseconds, milliseconds, seconds,"
" minutes, hours, and days.  Whitespace between the numeric constant and "
"time unit is optional.  Appending the letter ``s`` to the time unit in "
"order to pluralize it is also optional (to no semantic effect).  Examples"
" of ``interval`` constants are ``3.5 min`` and ``3.5mins``.  An "
"``interval`` can also be negated, for example ``-12 hr`` represents "
"\"twelve hours in the past\"."
msgstr ""

#: ../../script-reference/types.rst:190
msgid ""
"Intervals support addition and subtraction, the comparison operators "
"(``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``), the assignment operators "
"(``=``, ``+=``, ``-=``), and unary plus and minus (``+``, ``-``)."
msgstr ""

#: ../../script-reference/types.rst:194
msgid ""
"Intervals also support division (in which case the result is a "
":zeek:type:`double` value).  An ``interval`` can be multiplied or divided"
" by an arithmetic type (``count``, ``int``, or ``double``) to produce an "
"``interval`` value.  The absolute value of an ``interval`` is a "
"``double`` value equal to the number of seconds in the ``interval`` "
"(e.g., ``|-1 min|`` is 60.0)."
msgstr ""

#: ../../script-reference/types.rst:205
msgid "string"
msgstr ""

#: ../../script-reference/types.rst:207
msgid ""
"A type used to hold bytes which represent text and also can hold "
"arbitrary binary data."
msgstr ""

#: ../../script-reference/types.rst:210
msgid ""
"String constants are created by enclosing text within a pair of double "
"quotes (``\"``).  A string constant cannot span multiple lines in a Zeek "
"script. The backslash character (\\\\) introduces escape sequences. Zeek "
"recognizes the following escape sequences: ``\\\\``, ``\\n``, ``\\t``, "
"``\\v``, ``\\b``, ``\\r``, ``\\f``, ``\\a``, ``\\ooo`` (where each 'o' is"
" an octal digit), ``\\xhh`` (where each 'h' is a hexadecimal digit).  If "
"Zeek does not recognize an escape sequence, Zeek will ignore the "
"backslash (``\\\\g`` becomes ``g``)."
msgstr ""

#: ../../script-reference/types.rst:219
msgid ""
"Strings support concatenation (``+``), and assignment (``=``, ``+=``). "
"Strings also support the comparison operators (``==``, ``!=``, ``<``, "
"``<=``, ``>``, ``>=``).  The number of characters in a string can be "
"found by enclosing the string within pipe characters (e.g., ``|\"abc\"|``"
" is 3).  Substring searching can be performed using the ``in`` or ``!in``"
" operators (e.g., ``\"bar\" in \"foobar\"`` yields true)."
msgstr ""

#: ../../script-reference/types.rst:226
msgid ""
"The subscript operator can extract a substring of a string.  To do this, "
"specify the starting index to extract (if the starting index is omitted, "
"then zero is assumed), followed by a colon and index one past the last "
"character to extract (if the last index is omitted, then the extracted "
"substring will go to the end of the original string). However, if both "
"the colon and last index are omitted, then a string of length one is "
"extracted.  String indexing is zero-based, but an index of -1 refers to "
"the last character in the string, and -2 refers to the second-to-last "
"character, etc.  Here are a few examples:"
msgstr ""

#: ../../script-reference/types.rst:248
msgid ""
"Note that the subscript operator cannot be used to modify a string (i.e.,"
" it cannot be on the left side of an assignment operator)."
msgstr ""

#: ../../script-reference/types.rst:255
msgid "pattern"
msgstr ""

#: ../../script-reference/types.rst:257
msgid ""
"A type representing regular-expression patterns that can be used for fast"
" text-searching operations.  Pattern constants are created by enclosing "
"text within forward slashes (``/``) and use the same syntax as the "
"patterns supported by the `flex lexical analyzer "
"<http://westes.github.io/flex/manual/Patterns.html>`_.  The speed of "
"regular expression matching does not depend on the complexity or size of "
"the patterns.  Patterns support two types of matching, exact and "
"embedded."
msgstr ""

#: ../../script-reference/types.rst:266
msgid ""
"In exact matching the ``==`` equality relational operator is used with "
"one ``pattern`` operand and one :zeek:type:`string` operand (order of "
"operands does not matter) to check whether the full string exactly "
"matches the pattern.  In exact matching, the ``^`` beginning-of-line and "
"``$`` end-of-line anchors are redundant since the pattern is implicitly "
"anchored to the beginning and end of the line to facilitate an exact "
"match.  For example:"
msgstr ""

#: ../../script-reference/types.rst:278 ../../script-reference/types.rst:295
msgid "yields true, while:"
msgstr ""

#: ../../script-reference/types.rst:284
msgid "yields false.  The ``!=`` operator would yield the negation of ``==``."
msgstr ""

#: ../../script-reference/types.rst:286
msgid ""
"In embedded matching the ``in`` operator is used with one ``pattern`` "
"operand (which must be on the left-hand side) and one :zeek:type:`string`"
" operand, but tests whether the pattern appears anywhere within the given"
" string.  For example:"
msgstr ""

#: ../../script-reference/types.rst:301
msgid ""
"is false since ``\"oob\"`` does not appear at the start of "
"``\"foobar\"``.  The ``!in`` operator would yield the negation of ``in``."
msgstr ""

#: ../../script-reference/types.rst:304
msgid ""
"You can create a disjunction (either-or) of two patterns using the ``|`` "
"operator.  For example:"
msgstr ""

#: ../../script-reference/types.rst:311
msgid ""
"yields true, like in the similar example above.  You can also create the "
"conjunction (concatenation) of patterns using the ``&`` operator.  For "
"example:"
msgstr ""

#: ../../script-reference/types.rst:319
msgid ""
"will yield true because the pattern ``/(foo)(bar)/`` appears in the "
"string ``\"foobar\"``."
msgstr ""

#: ../../script-reference/types.rst:322
msgid ""
"When specifying a pattern, you can add a final ``i`` specifier to mark it"
" as case-insensitive.  For example, ``/foo|bar/i`` will match "
"``\"foo\"``, ``\"Foo\"``, ``\"BaR\"``, etc."
msgstr ""

#: ../../script-reference/types.rst:326
msgid ""
"You can also introduce a case-insensitive sub-pattern by enclosing it in "
"``(?i:<pattern>)``.  So, for example, ``/foo|(?i:bar)/`` will match "
"``\"foo\"`` and ``\"BaR\"``, but *not* ``\"Foo\"``."
msgstr ""

#: ../../script-reference/types.rst:330
msgid ""
"For both ways of specifying case-insensitivity, characters enclosed in "
"double quotes maintain their case-sensitivity.  So for example "
"``/\"foo\"/i`` will not match ``\"Foo\"``, but it will match ``\"foo\"``."
msgstr ""

#: ../../script-reference/types.rst:338
msgid "port"
msgstr ""

#: ../../script-reference/types.rst:340
msgid ""
"A type representing transport-level port numbers (besides TCP and UDP "
"ports, there is a concept of an ICMP ``port`` where the source port is "
"the ICMP message type and the destination port the ICMP message code).  A"
" ``port`` constant is written as an unsigned integer followed by one of "
"``/tcp``, ``/udp``, ``/icmp``, or ``/unknown``."
msgstr ""

#: ../../script-reference/types.rst:346
msgid ""
"Ports support the comparison operators (``==``, ``!=``, ``<``, ``<=``, "
"``>``, ``>=``).  When comparing order across transport-level protocols, "
"``unknown`` < ``tcp`` < ``udp`` < ``icmp``, for example ``65535/tcp`` is "
"smaller than ``0/udp``."
msgstr ""

#: ../../script-reference/types.rst:351
msgid ""
"Note that you can obtain the transport-level protocol type of a ``port`` "
"with the :zeek:id:`get_port_transport_proto` built-in function, and the "
"numeric value of a ``port`` with the :zeek:id:`port_to_count` built-in "
"function."
msgstr ""

#: ../../script-reference/types.rst:360
msgid "addr"
msgstr ""

#: ../../script-reference/types.rst:362
msgid "A type representing an IP address."
msgstr ""

#: ../../script-reference/types.rst:364
msgid ""
"IPv4 address constants are written in \"dotted quad\" format, "
"``A1.A2.A3.A4``, where Ai all lie between 0 and 255."
msgstr ""

#: ../../script-reference/types.rst:367
msgid ""
"IPv6 address constants are written as colon-separated hexadecimal form as"
" described by :rfc:`2373` (including the mixed notation with embedded "
"IPv4 addresses as dotted-quads in the lower 32 bits), but additionally "
"encased in square brackets.  Some examples: ``[2001:db8::1]``, "
"``[::ffff:192.168.1.100]``, or "
"``[aaaa:bbbb:cccc:dddd:eeee:ffff:1111:2222]``."
msgstr ""

#: ../../script-reference/types.rst:374
msgid ""
"Note that IPv4-mapped IPv6 addresses (i.e., addresses with the first 80 "
"bits zero, the next 16 bits one, and the remaining 32 bits are the IPv4 "
"address) are treated internally as IPv4 addresses (for example, "
"``[::ffff:192.168.1.100]`` is equal to ``192.168.1.100``)."
msgstr ""

#: ../../script-reference/types.rst:379
msgid ""
"Addresses can be compared for equality (``==``, ``!=``), and also for "
"ordering (``<``, ``<=``, ``>``, ``>=``).  The absolute value of an "
"address gives the size in bits (32 for IPv4, and 128 for IPv6). Addresses"
" can also be masked with ``/`` to produce a :zeek:type:`subnet`:"
msgstr ""

#: ../../script-reference/types.rst:392
msgid ""
"And checked for inclusion within a :zeek:type:`subnet` using ``in`` or "
"``!in``:"
msgstr ""

#: ../../script-reference/types.rst:403
msgid ""
"You can check if a given ``addr`` is IPv4 or IPv6 using the "
":zeek:id:`is_v4_addr` and :zeek:id:`is_v6_addr` built-in functions."
msgstr ""

#: ../../script-reference/types.rst:406
msgid ""
"Note that hostname constants can also be used, but since a hostname can "
"correspond to multiple IP addresses, the type of such a variable is "
"``set[addr]``. For example:"
msgstr ""

#: ../../script-reference/types.rst:418
msgid "subnet"
msgstr ""

#: ../../script-reference/types.rst:420
msgid ""
"A type representing a block of IP addresses in CIDR notation.  A "
"``subnet`` constant is written as an :zeek:type:`addr` followed by a "
"slash (``/``) and then the network prefix size specified as a decimal "
"number.  For example, ``192.168.0.0/16`` or ``[fe80::]/64``."
msgstr ""

#: ../../script-reference/types.rst:425
msgid ""
"Subnets can be compared for equality (``==``, ``!=``).  An "
":zeek:type:`addr` can be checked for inclusion in a subnet using the "
"``in`` or ``!in`` operators."
msgstr ""

#: ../../script-reference/types.rst:433
msgid "enum"
msgstr ""

#: ../../script-reference/types.rst:435
msgid ""
"A type allowing the specification of a set of related values that have no"
" further structure.  An example declaration:"
msgstr ""

#: ../../script-reference/types.rst:442
msgid ""
"The last comma after ``Blue`` is optional.  Both the type name ``color`` "
"and the individual values (``Red``, etc.) have global scope."
msgstr ""

#: ../../script-reference/types.rst:445
msgid ""
"Enumerations do not have associated values or ordering. The only "
"operations allowed on enumerations are equality comparisons (``==``, "
"``!=``) and assignment (``=``)."
msgstr ""

#: ../../script-reference/types.rst:453
msgid "table"
msgstr ""

#: ../../script-reference/types.rst:455
msgid ""
"An associate array that maps from one set of values to another.  The "
"values being mapped are termed the *index* or *indices* and the result of"
" the mapping is called the *yield*.  Indexing into tables is very "
"efficient, and internally it is just a single hash table lookup."
msgstr ""

#: ../../script-reference/types.rst:461
msgid "The table declaration syntax is::"
msgstr ""

#: ../../script-reference/types.rst:465
msgid ""
"where *type^+* is one or more types, separated by commas.  The index type"
" cannot be any of the following types:  :zeek:type:`pattern`, "
":zeek:type:`table`, :zeek:type:`set`, :zeek:type:`vector`, "
":zeek:type:`file`, :zeek:type:`opaque`, :zeek:type:`any`."
msgstr ""

#: ../../script-reference/types.rst:470
msgid ""
"Here is an example of declaring a table indexed by :zeek:type:`count` "
"values and yielding :zeek:type:`string` values:"
msgstr ""

#: ../../script-reference/types.rst:477
msgid "The yield type can also be more complex:"
msgstr ""

#: ../../script-reference/types.rst:483
msgid ""
"which declares a table indexed by :zeek:type:`count` and yielding another"
" ``table`` which is indexed by an :zeek:type:`addr` and :zeek:type:`port`"
" to yield a :zeek:type:`string`."
msgstr ""

#: ../../script-reference/types.rst:487
msgid ""
"One way to initialize a table is by enclosing a set of initializers "
"within braces, for example:"
msgstr ""

#: ../../script-reference/types.rst:497
msgid "A table constructor can also be used to create a table:"
msgstr ""

#: ../../script-reference/types.rst:506
msgid ""
"Table constructors can also be explicitly named by a type, which is "
"useful when a more complex index type could otherwise be ambiguous:"
msgstr ""

#: ../../script-reference/types.rst:521
msgid ""
"Accessing table elements is provided by enclosing index values within "
"square brackets (``[]``), for example:"
msgstr ""

#: ../../script-reference/types.rst:528
msgid "And membership can be tested with ``in`` or ``!in``:"
msgstr ""

#: ../../script-reference/types.rst:537
msgid "Add or overwrite individual table elements by assignment:"
msgstr ""

#: ../../script-reference/types.rst:543
msgid "Remove individual table elements with :zeek:keyword:`delete`:"
msgstr ""

#: ../../script-reference/types.rst:549
msgid ""
"Nothing happens if the element with index value ``13`` isn't present in "
"the table."
msgstr ""

#: ../../script-reference/types.rst:552
msgid ""
"The number of elements in a table can be obtained by placing the table "
"identifier between vertical pipe characters:"
msgstr ""

#: ../../script-reference/types.rst:559
msgid ""
"See the :zeek:keyword:`for` statement for info on how to iterate over the"
" elements in a table."
msgstr ""

#: ../../script-reference/types.rst:562
msgid ""
"It's common to extend the behavior of table lookup and membership "
"lifetimes via :doc:`attributes <attributes>` but note that it's also a "
":ref:`confusing pitfall <attribute-propagation-pitfalls>` that attributes"
" bind to initial *values* instead of *type* or *variable* and do not "
"currently propagate to any new *value* subsequently re-assigned to the "
"table *variable*."
msgstr ""

#: ../../script-reference/types.rst:572
msgid "set"
msgstr ""

#: ../../script-reference/types.rst:574
msgid ""
"A set is like a :zeek:type:`table`, but it is a collection of indices "
"that do not map to any yield value.  They are declared with the syntax::"
msgstr ""

#: ../../script-reference/types.rst:580
msgid ""
"where *type^+* is one or more types separated by commas.  The index type "
"cannot be any of the following types:  :zeek:type:`pattern`, "
":zeek:type:`table`, :zeek:type:`set`, :zeek:type:`vector`, "
":zeek:type:`file`, :zeek:type:`opaque`, :zeek:type:`any`."
msgstr ""

#: ../../script-reference/types.rst:585
msgid "Sets can be initialized by listing elements enclosed by curly braces:"
msgstr ""

#: ../../script-reference/types.rst:592
msgid ""
"A set constructor (equivalent to above example) can also be used to "
"create a set:"
msgstr ""

#: ../../script-reference/types.rst:599
msgid ""
"Set constructors can also be explicitly named by a type, which is useful "
"when a more complex index type could otherwise be ambiguous:"
msgstr ""

#: ../../script-reference/types.rst:614
msgid "Set membership is tested with ``in`` or ``!in``:"
msgstr ""

#: ../../script-reference/types.rst:624
msgid "Elements are added with :zeek:keyword:`add`:"
msgstr ""

#: ../../script-reference/types.rst:630
msgid ""
"Nothing happens if the element with value ``22/tcp`` was already present "
"in the set."
msgstr ""

#: ../../script-reference/types.rst:633
msgid "And removed with :zeek:keyword:`delete`:"
msgstr ""

#: ../../script-reference/types.rst:639
msgid ""
"Nothing happens if the element with value ``21/tcp`` isn't present in the"
" set."
msgstr ""

#: ../../script-reference/types.rst:642
msgid ""
"The number of elements in a set can be obtained by placing the set "
"identifier between vertical pipe characters:"
msgstr ""

#: ../../script-reference/types.rst:649
msgid ""
"You can compute the union, intersection, or difference of two sets using "
"the ``|``, ``&``, and ``-`` operators."
msgstr ""

#: ../../script-reference/types.rst:652
msgid ""
"You can compare sets for equality (they have exactly the same elements) "
"using ``==``.  The ``<`` operator returns ``T`` if the lefthand operand "
"is a proper subset of the righthand operand.  Similarly, ``<=`` returns "
"``T`` if the lefthand operator is a subset (not necessarily proper, i.e.,"
" it may be equal to the righthand operand).  The operators ``!=``, ``>`` "
"and ``>=`` provide the expected complementary operations."
msgstr ""

#: ../../script-reference/types.rst:659
msgid ""
"See the :zeek:keyword:`for` statement for info on how to iterate over the"
" elements in a set."
msgstr ""

#: ../../script-reference/types.rst:666
msgid "vector"
msgstr ""

#: ../../script-reference/types.rst:668
msgid ""
"A vector is like a :zeek:type:`table`, except its indices are non-"
"negative integers, starting from zero.  A vector is declared like:"
msgstr ""

#: ../../script-reference/types.rst:675
msgid "And can be initialized with the vector constructor:"
msgstr ""

#: ../../script-reference/types.rst:681
msgid ""
"Vector constructors can also be explicitly named by a type, which is "
"useful for when a more complex yield type could otherwise be ambiguous."
msgstr ""

#: ../../script-reference/types.rst:696
msgid ""
"Access individual vector elements by enclosing index values within square"
" brackets (``[]``), for example:"
msgstr ""

#: ../../script-reference/types.rst:703
msgid ""
"Access a slice of vector elements by enclosing a range of indices, "
"delimited by a colon, within square brackets (``[x:y]``).  For example, "
"this will print a vector containing the first and second elements:"
msgstr ""

#: ../../script-reference/types.rst:711
msgid ""
"The slicing notation is the same as what is permitted by the "
":zeek:see:`string` substring extraction operations."
msgstr ""

#: ../../script-reference/types.rst:714
msgid ""
"An element can be added to a vector by assigning the value (a value that "
"already exists at that index will be overwritten):"
msgstr ""

#: ../../script-reference/types.rst:721
msgid "A range of elements can be *replaced* by assigning to a vector slice:"
msgstr ""

#: ../../script-reference/types.rst:730
msgid ""
"The size of a vector (this is one greater than the highest index value, "
"and is normally equal to the number of elements in the vector) can be "
"obtained by placing the vector identifier between vertical pipe "
"characters:"
msgstr ""

#: ../../script-reference/types.rst:738
msgid ""
"A particularly common operation on a vector is to append an element to "
"its end.  You can do so using:"
msgstr ""

#: ../../script-reference/types.rst:745
msgid ""
"where if *e*'s type is ``X``, *v*'s type is ``vector of X``.  Note that "
"this expression is equivalent to:"
msgstr ""

#: ../../script-reference/types.rst:752
msgid ""
"The ``in`` operator can be used to check if a value has been assigned at "
"a specified index value in the vector.  For example, if a vector has size"
" 4, then the expression ``3 in v`` would yield true and ``4 in v`` would "
"yield false."
msgstr ""

#: ../../script-reference/types.rst:757
msgid ""
"Vectors of integral types (``int`` or ``count``) support the pre-"
"increment (``++``) and pre-decrement operators (``--``), which will "
"increment or decrement each element in the vector."
msgstr ""

#: ../../script-reference/types.rst:761
msgid ""
"Vectors of arithmetic types (``int``, ``count``, or ``double``) can be "
"operands of the arithmetic operators (``+``, ``-``, ``*``, ``/``, ``%``),"
" but both operands must have the same number of elements (and the modulus"
" operator ``%`` cannot be used if either operand is a ``vector of "
"double``). The resulting vector contains the result of the operation "
"applied to each of the elements in the operand vectors."
msgstr ""

#: ../../script-reference/types.rst:768
msgid ""
"Vectors of bool can be operands of the logical \"and\" (``&&``) and "
"logical \"or\" (``||``) operators (both operands must have same number of"
" elements). The resulting vector of bool is the logical \"and\" (or "
"logical \"or\") of each element of the operand vectors."
msgstr ""

#: ../../script-reference/types.rst:773
msgid ""
"Vectors of type ``count`` can also be operands for the bitwise and/or/xor"
" operators, ``&``, ``|`` and ``^``."
msgstr ""

#: ../../script-reference/types.rst:776
msgid ""
"See the :zeek:keyword:`for` statement for info on how to iterate over the"
" elements in a vector."
msgstr ""

#: ../../script-reference/types.rst:783
msgid "record"
msgstr ""

#: ../../script-reference/types.rst:785
msgid ""
"A ``record`` is a collection of values.  Each value has a field name and "
"a type.  Values do not need to have the same type and the types have no "
"restrictions.  Field names must follow the same syntax as regular "
"variable names (except that field names are allowed to be the same as "
"local or global variables).  An example record type definition:"
msgstr ""

#: ../../script-reference/types.rst:799
msgid ""
"Records can be initialized or assigned as a whole in three different "
"ways. When assigning a whole record value, all fields that are not "
":zeek:attr:`&optional` or have a :zeek:attr:`&default` attribute must be "
"specified.  First, there's a constructor syntax:"
msgstr ""

#: ../../script-reference/types.rst:808
msgid ""
"And the constructor can be explicitly named by type, too, which is "
"arguably more readable:"
msgstr ""

#: ../../script-reference/types.rst:815
msgid "And the third way is like this:"
msgstr ""

#: ../../script-reference/types.rst:821
msgid ""
"Access to a record field uses the dollar sign (``$``) operator, and "
"record fields can be assigned with this:"
msgstr ""

#: ../../script-reference/types.rst:829
msgid ""
"To test if a field that is :zeek:attr:`&optional` has been assigned a "
"value, use the ``?$`` operator (it returns a :zeek:type:`bool` value of "
"``T`` if the field has been assigned a value, or ``F`` if not):"
msgstr ""

#: ../../script-reference/types.rst:842
msgid "function"
msgstr ""

#: ../../script-reference/types.rst:844
msgid "Function types in Zeek are declared using::"
msgstr ""

#: ../../script-reference/types.rst:848
msgid ""
"where *argument* is a (possibly empty) comma-separated list of arguments,"
" and *type* is an optional return type.  For example:"
msgstr ""

#: ../../script-reference/types.rst:855
msgid ""
"Here ``greeting`` is an identifier with a certain function type. The "
"function body is not defined yet and ``greeting`` could even have "
"different function body values at different times.  To define a function "
"including a body value, the syntax is like:"
msgstr ""

#: ../../script-reference/types.rst:867
msgid ""
"Note that in the definition above, it's not necessary for us to have done"
" the first (forward) declaration of ``greeting`` as a function type, but "
"when it is, the return type and argument list (including the name of each"
" argument) must match exactly."
msgstr ""

#: ../../script-reference/types.rst:872
msgid ""
"Here is an example function that takes no parameters and does not return "
"a value:"
msgstr ""

#: ../../script-reference/types.rst:882
msgid "Function types don't need to have a name and can be assigned anonymously:"
msgstr ""

#: ../../script-reference/types.rst:888
msgid "And finally, the function can be called like:"
msgstr ""

#: ../../script-reference/types.rst:894
msgid ""
"Anonymously defined functions capture their closures. This means that "
"they can use and modify variables from their enclosing scope at the time "
"of their creation. Here is an example of a simple anonymous function that"
" captures its closure in Zeek:"
msgstr ""

#: ../../script-reference/types.rst:914
msgid ""
"Here `make_adder` is generating a function that captures `n` in its "
"closure."
msgstr ""

#: ../../script-reference/types.rst:916
msgid ""
"Anonymous functions capture their closures by reference. This means that "
"they can modify the variables in their closures. For example:"
msgstr ""

#: ../../script-reference/types.rst:926
msgid ""
"When anonymous functions are serialized over Broker they keep their "
"closures, but they will not continue to mutate the values from the "
"sending script. At the time of serialization they create a copy of their "
"closure. Anonymous function's do not capture global variables in their "
"closures though and will use the receivers global variables."
msgstr ""

#: ../../script-reference/types.rst:932
msgid ""
"In order to serialize an anonymous function, that function must have been"
" already declared on the receivers end because Zeek will not serialize "
"the function's source code. See `testing/btest/language/closure-"
"sending.zeek` for an example of how to serialize anonymous functions over"
" Broker."
msgstr ""

#: ../../script-reference/types.rst:937
msgid ""
"Function parameters may specify default values as long as they appear "
"last in the parameter list:"
msgstr ""

#: ../../script-reference/types.rst:944
msgid ""
"If a function was previously declared with default parameters, the "
"default expressions can be omitted when implementing the function body "
"and they will still be used for function calls that lack those arguments."
msgstr ""

#: ../../script-reference/types.rst:956
msgid "And calls to the function may omit the defaults from the argument list:"
msgstr ""

#: ../../script-reference/types.rst:966
msgid "event"
msgstr ""

#: ../../script-reference/types.rst:968
msgid ""
"Event handlers are nearly identical in both syntax and semantics to a "
":zeek:type:`function`, with the two differences being that event handlers"
" have no return type since they never return a value, and you cannot call"
" an event handler."
msgstr ""

#: ../../script-reference/types.rst:973
msgid "Example:"
msgstr ""

#: ../../script-reference/types.rst:982
msgid ""
"Instead of directly calling an event handler from a script, event handler"
" bodies are executed when they are invoked by one of three different "
"methods:"
msgstr ""

#: ../../script-reference/types.rst:986
msgid "From the event engine"
msgstr ""

#: ../../script-reference/types.rst:988
msgid ""
"When the event engine detects an event for which you have defined a "
"corresponding event handler, it queues an event for that handler.  The "
"handler is invoked as soon as the event engine finishes processing the "
"current packet and flushing the invocation of other event handlers that "
"were queued first."
msgstr ""

#: ../../script-reference/types.rst:994
msgid "With the ``event`` statement from a script"
msgstr ""

#: ../../script-reference/types.rst:996
msgid "Immediately queuing invocation of an event handler occurs like:"
msgstr ""

#: ../../script-reference/types.rst:1002
msgid ""
"This assumes that ``password_exposed`` was previously declared as an "
"event handler type with compatible arguments."
msgstr ""

#: ../../script-reference/types.rst:1005
msgid "Via the :zeek:keyword:`schedule` expression in a script"
msgstr ""

#: ../../script-reference/types.rst:1007
msgid ""
"This delays the invocation of event handlers until some time in the "
"future.  For example:"
msgstr ""

#: ../../script-reference/types.rst:1014
msgid ""
"Multiple event handler bodies can be defined for the same event handler "
"identifier and the body of each will be executed in turn.  Ordering of "
"execution can be influenced with :zeek:attr:`&priority`."
msgstr ""

#: ../../script-reference/types.rst:1018
msgid ""
"Multiple alternate event prototype declarations are allowed, but the "
"alternates must be some subset of the first, canonical prototype and "
"arguments must match by name and type.  This allows users to define "
"handlers for any such prototype they may find convenient or for the core "
"set of handlers to be extended, changed, or deprecated without breaking "
"existing handlers a user may have written.  Example:"
msgstr ""

#: ../../script-reference/types.rst:1048
msgid ""
"By using alternate event prototypes, handlers are allowed to consume a "
"subset of the full argument list as given by the first prototype "
"declaration.  It also even allows arguments to be ordered differently "
"from the canonical prototype."
msgstr ""

#: ../../script-reference/types.rst:1053
msgid ""
"To use :zeek:attr:`&default` on event arguments, it must appear on the "
"first, canonical prototype."
msgstr ""

#: ../../script-reference/types.rst:1060
msgid "hook"
msgstr ""

#: ../../script-reference/types.rst:1062
msgid ""
"A hook is another flavor of function that shares characteristics of both "
"a :zeek:type:`function` and an :zeek:type:`event`.  They are like events "
"in that many handler bodies can be defined for the same hook identifier "
"and the order of execution can be enforced with :zeek:attr:`&priority`.  "
"They are more like functions in the way they are invoked/called, because,"
" unlike events, their execution is immediate and they do not get "
"scheduled through an event queue. Also, a unique feature of a hook is "
"that a given hook handler body can short-circuit the execution of "
"remaining hook handlers simply by exiting from the body as a result of a "
":zeek:keyword:`break` statement (as opposed to a :zeek:keyword:`return` "
"or just reaching the end of the body)."
msgstr ""

#: ../../script-reference/types.rst:1074
msgid "A hook type is declared like::"
msgstr ""

#: ../../script-reference/types.rst:1078
msgid ""
"where *argument* is a (possibly empty) comma-separated list of arguments."
"  For example:"
msgstr ""

#: ../../script-reference/types.rst:1085
msgid ""
"Here ``myhook`` is the hook type identifier and no hook handler bodies "
"have been defined for it yet.  To define some hook handler bodies the "
"syntax looks like:"
msgstr ""

#: ../../script-reference/types.rst:1108
msgid ""
"Note that the first (forward) declaration of ``myhook`` as a hook type "
"isn't strictly required.  Argument types must match for all hook handlers"
" and any forward declaration of a given hook."
msgstr ""

#: ../../script-reference/types.rst:1112
msgid ""
"To invoke immediate execution of all hook handler bodies, they are called"
" similarly to a function, except preceded by the ``hook`` keyword:"
msgstr ""

#: ../../script-reference/types.rst:1120
msgid "or"
msgstr ""

#: ../../script-reference/types.rst:1127
msgid "And the output would look like::"
msgstr ""

#: ../../script-reference/types.rst:1132
msgid ""
"Note how the modification to arguments can be seen by remaining hook "
"handlers."
msgstr ""

#: ../../script-reference/types.rst:1135
msgid ""
"The return value of a hook call is an implicit :zeek:type:`bool` value "
"with ``T`` meaning that all handlers for the hook were executed and ``F``"
" meaning that only some of the handlers may have executed due to one "
"handler body exiting as a result of a ``break`` statement."
msgstr ""

#: ../../script-reference/types.rst:1141
msgid ""
"Hooks are also allowed to have multple/alternate prototype declarations, "
"just like an :zeek:see:`event`."
msgstr ""

#: ../../script-reference/types.rst:1148
msgid "file"
msgstr ""

#: ../../script-reference/types.rst:1150
msgid ""
"Zeek supports writing to files, but not reading from them (to read from "
"files see the :doc:`/frameworks/input`).  Files can be opened using "
"either the :zeek:id:`open` or :zeek:id:`open_for_append` built-in "
"functions, and closed using the :zeek:id:`close` built-in function.  For "
"example, declare, open, and write to a file and finally close it like:"
msgstr ""

#: ../../script-reference/types.rst:1163
msgid ""
"Writing to files like this for logging usually isn't recommended, for "
"better logging support see :doc:`/frameworks/logging`."
msgstr ""

#: ../../script-reference/types.rst:1170
msgid "opaque"
msgstr ""

#: ../../script-reference/types.rst:1172
msgid ""
"A data type whose actual representation/implementation is intentionally "
"hidden, but whose values may be passed to certain built-in functions that"
" can actually access the internal/hidden resources. Opaque types are "
"differentiated from each other by qualifying them like \"opaque of md5\" "
"or \"opaque of sha1\"."
msgstr ""

#: ../../script-reference/types.rst:1178
msgid ""
"An example use of this type is the set of built-in functions which "
"perform hashing:"
msgstr ""

#: ../../script-reference/types.rst:1189
msgid ""
"Here the opaque type is used to provide a handle to a particular resource"
" which is calculating an MD5 hash incrementally over time, but the "
"details of that resource aren't relevant, it's only necessary to have a "
"handle as a way of identifying it and distinguishing it from other such "
"resources."
msgstr ""

#: ../../script-reference/types.rst:1195
msgid ""
"The scripting layer implementations of these types are found primarily in"
" :doc:`/scripts/base/bif/zeek.bif.zeek` and a more granular look at them "
"can be found in ``src/OpaqueVal.h/cc`` inside the Zeek repo. Opaque types"
" are a good way to integrate functionality into Zeek without needing to "
"add an entire new type to the scripting language."
msgstr ""

#: ../../script-reference/types.rst:1203
msgid ""
"An opaque type for creating and using paraglob data structures inside of "
"Zeek. A paraglob is a data structure for fast string matching against a "
"large set of glob style patterns. It can be loaded with a vector of "
"patterns, and then queried with input strings. Note that these patterns "
"are just strings, and not the pattern type built in to Zeek. For a query "
"it returns all of the patterns that it contains matching that input "
"string."
msgstr ""

#: ../../script-reference/types.rst:1210
msgid ""
"Paraglobs offer significant performance advantages over making a pass "
"over a vector of patterns and checking each one. Note though that "
"initializing a paraglob can take some time for very large pattern sets "
"(1,000,000+ patterns) and care should be taken to only initialize one "
"with a large pattern set when there is time for the paraglob to compile. "
"Subsequent get operations run very quickly though, even for very large "
"pattern sets."
msgstr ""

#: ../../script-reference/types.rst:1224
msgid "For more documentation on paraglob see :doc:`/components/index`."
msgstr ""

#: ../../script-reference/types.rst:1233
msgid "any"
msgstr ""

#: ../../script-reference/types.rst:1235
msgid ""
"Used to bypass strong typing.  For example, a function can take an "
"argument of type ``any`` when it may be of different types. The only "
"operation allowed on a variable of type ``any`` is assignment."
msgstr ""

#: ../../script-reference/types.rst:1239
msgid ""
"Note that users aren't expected to use this type.  It's provided mainly "
"for use by some built-in functions and scripts included with Zeek. For "
"example, passing a vector into a ``.bif`` function is best accomplished "
"by taking :zeek:type:`any` as an argument and casting it to a vector."
msgstr ""

#: ../../script-reference/types.rst:1248
msgid "void"
msgstr ""

#: ../../script-reference/types.rst:1250
msgid ""
"An internal Zeek type (i.e., \"void\" is not a reserved keyword in the "
"Zeek scripting language) representing the absence of a return type for a "
"function."
msgstr ""

