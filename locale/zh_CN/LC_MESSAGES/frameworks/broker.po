# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, The Zeek Project
# This file is distributed under the same license as the Zeek package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Zeek source\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-28 21:33+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../frameworks/broker.rst:7
msgid "Broker-Enabled Communication/Cluster Framework"
msgstr ""

#: ../../frameworks/broker.rst:11
msgid ""
"Zeek now uses the `Broker Library "
"<https://docs.zeek.org/projects/broker>`_ to exchange information with "
"other Zeek processes.  Broker itself uses CAF_ (C++ Actor Framework) "
"internally for connecting nodes and exchanging arbitrary data over "
"networks.  Broker then introduces, on top of CAF, a topic-based "
"publish/subscribe communication pattern using a data model that is "
"compatible to Zeek's.  Broker itself can be utilized outside the context "
"of Zeek, with Zeek itself making use of only a few predefined Broker "
"message formats that represent Zeek events, log entries, etc."
msgstr ""

#: ../../frameworks/broker.rst:21
msgid ""
"In summary, the Zeek's Broker framework provides basic facilities for "
"connecting broker-enabled peers (e.g. Zeek instances) to each other and "
"exchanging messages (e.g. events and logs)."
msgstr ""

#: ../../frameworks/broker.rst:26
msgid "Cluster Layout / API"
msgstr ""

#: ../../frameworks/broker.rst:29
msgid "Layout / Topology"
msgstr ""

#: ../../frameworks/broker.rst:31
msgid "Each worker node connects to all proxies."
msgstr ""

#: ../../frameworks/broker.rst:33
msgid "All node types connect to all logger nodes and the manager node."
msgstr ""

#: ../../frameworks/broker.rst:37
msgid "Some general suggestions as to the purpose/utilization of each node type:"
msgstr ""

#: ../../frameworks/broker.rst:39
msgid ""
"Workers: are a good first choice for doing the brunt of any work you need"
" done.  They should be spending a lot of time performing the actual job "
"of parsing/analyzing incoming data from packets, so you might choose to "
"look at them as doing a \"first pass\" analysis and then deciding how the"
" results should be shared with other nodes in the cluster."
msgstr ""

#: ../../frameworks/broker.rst:45
msgid ""
"Proxies: serve as intermediaries for data storage and work/calculation "
"offloading.  Good for helping offload work or data in a scalable and "
"distributed way.  Since any given worker is connected to all proxies and "
"can agree on an \"arbitrary key -> proxy node\" mapping (more on that "
"later), you can partition work or data amongst them in a uniform manner."
"  e.g. you might choose to use proxies as a method of sharing non-"
"persistent state or as a \"second pass\" analysis for any work that you "
"don't want interfering with the workers' capacity to keep up with "
"capturing and parsing packets.  Note that the default scripts that come "
"with Zeek make minimal use of proxies, so if you are coming from a "
"previous ZeekControl deployment, you may want to try reducing down to a "
"single proxy node.  If you come to have custom/community scripts that "
"utilize proxies, that would be the time to start considering scaling up "
"the number of proxies to meet demands."
msgstr ""

#: ../../frameworks/broker.rst:60
msgid ""
"Manager: this node will be good at performing decisions that require a "
"global view of things since it is in a centralized location, connected to"
" everything.  However, that also makes it easy to overload, so try to use"
" it sparingly and only for tasks that must be done in a centralized or "
"authoritative location. Optionally, for some deployments, the Manager can"
" also serve as the sole Logger."
msgstr ""

#: ../../frameworks/broker.rst:67
msgid ""
"Loggers: these nodes should simply be spending their time writing out "
"logs to disk and not used for much else.  In the default cluster "
"configuration, logs get distributed among available loggers in a round-"
"robin fashion, providing failover capability should any given logger "
"temporarily go offline."
msgstr ""

#: ../../frameworks/broker.rst:74
msgid "Data Management/Sharing Strategies"
msgstr ""

#: ../../frameworks/broker.rst:76
msgid ""
"There's maybe no single, best approach or pattern to use when you need a "
"Zeek script to store or share long-term state and data.  The two "
"approaches that were previously used were either using the "
"``&synchronized`` attribute on tables/sets or by explicitly sending "
"events to specific nodes on which you wanted data to be stored.  The "
"former is no longer possible, though there are several new possibilities "
"that the new Broker/Cluster framework offer, namely distributed data "
"store and data partitioning APIs."
msgstr ""

#: ../../frameworks/broker.rst:86
msgid "Data Stores"
msgstr ""

#: ../../frameworks/broker.rst:88
msgid ""
"Broker provides a distributed key-value store interface with optional "
"choice of using a persistent backend. For more detail, see :ref:`this "
"example <data_store_example>`."
msgstr ""

#: ../../frameworks/broker.rst:92
msgid ""
"Some ideas/considerations/scenarios when deciding whether to use a data "
"store for your use-case:"
msgstr ""

#: ../../frameworks/broker.rst:95
msgid ""
"If you need the full data set locally in order to achieve low-latency "
"queries using data store \"clones\" can provide that."
msgstr ""

#: ../../frameworks/broker.rst:98
msgid ""
"If you need data that persists across restarts of Zeek processes, then "
"data stores can also provide that."
msgstr ""

#: ../../frameworks/broker.rst:101
msgid ""
"If the data you want to store is complex (tables, sets, records) or you "
"expect to read, modify, and store back, then data stores may not be able "
"to provide simple, race-free methods of performing the pattern of logic "
"that you want."
msgstr ""

#: ../../frameworks/broker.rst:106
msgid ""
"If the data set you want to store is excessively large, that's still "
"problematic even for stores that use a persistent backend as they are "
"implemented in a way that requires a full snapshot of the store's "
"contents to fit in memory (this limitation may change in the future)."
msgstr ""

#: ../../frameworks/broker.rst:112
msgid "Data Partitioning"
msgstr ""

#: ../../frameworks/broker.rst:114
msgid ""
"New data partitioning strategies are available using the API in "
":doc:`/scripts/base/frameworks/cluster/pools.zeek`.  Using that API, "
"developers of custom Zeek scripts can define a custom pool of nodes that "
"best fits the needs of their script."
msgstr ""

#: ../../frameworks/broker.rst:119
msgid ""
"One example strategy is to use Highest Random Weight (HRW) hashing to "
"partition data tables amongst the pool of all proxy nodes.  e.g. using "
":zeek:see:`Cluster::publish_hrw`.  This could allow clusters to be scaled"
" more easily than the approach of \"the entire data set gets synchronized"
" to all nodes\" as the solution to memory limitations becomes \"just add "
"another proxy node\".  It may also take away some of the messaging load "
"that used to be required to synchronize data sets across all nodes."
msgstr ""

#: ../../frameworks/broker.rst:128
msgid ""
"The tradeoff of this approach, is that nodes that leave the pool (due to "
"crashing, etc.) cause a temporary gap in the total data set until workers"
" start hashing keys to a new proxy node that is still alive, causing data"
" to now be located and updated there."
msgstr ""

#: ../../frameworks/broker.rst:133
msgid ""
"If the developer of a script expects its workload to be particularly "
"intensive, wants to ensure that their operations get exclusive access to "
"nodes, or otherwise set constraints on the number of nodes within a pool "
"utilized by their script, then the :zeek:see:`Cluster::PoolSpec` "
"structure will allow them to do that while still allowing users of that "
"script to override the default suggestions made by the original "
"developer."
msgstr ""

#: ../../frameworks/broker.rst:141
msgid "Broker Framework Examples"
msgstr ""

#: ../../frameworks/broker.rst:143
msgid ""
"The broker framework provides basic facilities for connecting Zeek "
"instances to each other and exchanging messages, like events or logs."
msgstr ""

#: ../../frameworks/broker.rst:146
msgid ""
"See :doc:`/scripts/base/frameworks/broker/main.zeek` for an overview of "
"the main Broker API."
msgstr ""

#: ../../frameworks/broker.rst:152
msgid "Topic Naming Conventions"
msgstr ""

#: ../../frameworks/broker.rst:154
msgid ""
"All Broker-based messaging involves two components: the information you "
"want to send (e.g. an event w/ its arguments) along with an associated "
"topic name string.  The topic strings are used as a filtering mechanism: "
"Broker uses a publish/subscribe communication pattern where peers "
"advertise interest in topic **prefixes** and only receive messages which "
"match one of their prefix subscriptions."
msgstr ""

#: ../../frameworks/broker.rst:161
msgid ""
"Broker itself supports arbitrary topic strings, however Zeek generally "
"follows certain conventions in choosing these topics to help avoid "
"conflicts and generally make them easier to remember."
msgstr ""

#: ../../frameworks/broker.rst:165
msgid ""
"As a reminder of how topic subscriptions work, subscribers advertise "
"interest in a topic **prefix** and then receive any messages published by"
" a peer to a topic name that starts with that prefix.  E.g. Alice "
"subscribes to the \"alice/dogs\" prefix, then would receive the following"
" message topics published by Bob:"
msgstr ""

#: ../../frameworks/broker.rst:171
msgid "topic \"alice/dogs/corgi\""
msgstr ""

#: ../../frameworks/broker.rst:172
msgid "topic \"alice/dogs\""
msgstr ""

#: ../../frameworks/broker.rst:173
msgid "topic \"alice/dogsarecool/oratleastilikethem\""
msgstr ""

#: ../../frameworks/broker.rst:175
msgid "Alice would **not** receive the following message topics published by Bob:"
msgstr ""

#: ../../frameworks/broker.rst:177
msgid "topic \"alice/cats/siamese\""
msgstr ""

#: ../../frameworks/broker.rst:178
msgid "topic \"alice/cats\""
msgstr ""

#: ../../frameworks/broker.rst:179
msgid "topic \"alice/dog\""
msgstr ""

#: ../../frameworks/broker.rst:180
msgid "topic \"alice\""
msgstr ""

#: ../../frameworks/broker.rst:182
msgid ""
"Note that the topics aren't required to form a slash-delimited hierarchy,"
" the subscription matching is purely a byte-per-byte prefix comparison."
msgstr ""

#: ../../frameworks/broker.rst:185
msgid ""
"However, Zeek scripts generally will follow a topic naming hierarchy and "
"any given script will make the topic names it uses apparent via some "
"redef'able constant in its export section.  Generally topics that Zeek "
"scripts use will be along the lines of \"zeek/<namespace>/<specifics>\" "
"with \"<namespace>\" being the script's module name (in all-undercase). "
"For example, you might expect an imaginary \"Pretend\" framework to "
"publish/subscribe using topic names like \"zeek/pretend/my_cool_event\". "
"For scripts that use Broker as a means of cluster-aware analysis, it's "
"usually sufficient for them to make use of the topics declared by the "
"cluster framework.  For scripts that are meant to establish communication"
" flows unrelated to Zeek cluster, new topics are declared (examples being"
" the NetControl and Control frameworks)."
msgstr ""

#: ../../frameworks/broker.rst:198
msgid ""
"For cluster operation, see "
":doc:`/scripts/base/frameworks/cluster/main.zeek` for a list of topics "
"that are useful for steering published events to the various node "
"classes.  E.g. you have the ability to broadcast to all nodes of a given "
"class (e.g. just workers) or just send to a specific node within a class."
msgstr ""

#: ../../frameworks/broker.rst:204
msgid ""
"The topic names that logs get published under are a bit nuanced.  In the "
"default cluster configuration, they are round-robin published to explicit"
" topic names that identify a single logger.  In standalone Zeek "
"processes, logs get published to the topic indicated by "
":zeek:see:`Broker::default_log_topic_prefix`."
msgstr ""

#: ../../frameworks/broker.rst:210
msgid ""
"For those writing their own scripts which need new topic names, a "
"suggestion would be to avoid prefixing any new topics/prefixes with "
"\"zeek/\" as any changes in scripts shipping with Zeek will use that "
"prefix and it's better to not risk unintended conflicts.  Again, it's "
"often less confusing to just re-use existing topic names instead of "
"introducing new topic names.  The typical use case is writing a cluster-"
"enabled script, which usually just needs to route events based upon node "
"classes, and that already has usable topics in the cluster framework."
msgstr ""

#: ../../frameworks/broker.rst:221
msgid "Connecting to Peers"
msgstr ""

#: ../../frameworks/broker.rst:223
msgid ""
"Zeek can accept incoming connections by calling "
":zeek:see:`Broker::listen`."
msgstr ""

#: ../../frameworks/broker.rst:225
msgid "connecting-listener.zeek"
msgstr ""

#: ../../frameworks/broker.rst:231
msgid ""
"Zeek can initiate outgoing connections by calling "
":zeek:see:`Broker::peer`."
msgstr ""

#: ../../frameworks/broker.rst:233
msgid "connecting-connector.zeek"
msgstr ""

#: ../../frameworks/broker.rst:239
msgid ""
"In either case, connection status updates are monitored via the "
":zeek:see:`Broker::peer_added` and :zeek:see:`Broker::peer_lost` events."
msgstr ""

#: ../../frameworks/broker.rst:243
msgid "Remote Events"
msgstr ""

#: ../../frameworks/broker.rst:245
msgid ""
"To receive remote events, you need to first subscribe to a \"topic\" to "
"which the events are being sent.  A topic is just a string chosen by the "
"sender, and named in a way that helps organize events into various "
"categories. See the :ref:`topic naming conventions section "
"<broker_topic_naming>` for more on how topics work and are chosen."
msgstr ""

#: ../../frameworks/broker.rst:251
msgid ""
"Use the :zeek:see:`Broker::subscribe` function to subscribe to topics and"
" define any event handlers for events that peers will send."
msgstr ""

#: ../../frameworks/broker.rst:254
msgid "events-listener.zeek"
msgstr ""

#: ../../frameworks/broker.rst:260
msgid "There are two different ways to send events."
msgstr ""

#: ../../frameworks/broker.rst:262
msgid ""
"The first is to call the :zeek:see:`Broker::publish` function which you "
"can supply directly with the event and its arguments or give it the "
"return value of :zeek:see:`Broker::make_event` in case you need to send "
"the same event/args multiple times.  When publishing events like this, "
"local event handlers for the event are not called."
msgstr ""

#: ../../frameworks/broker.rst:268
msgid ""
"The second option is to call the :zeek:see:`Broker::auto_publish` "
"function where you specify a particular event that will be automatically "
"sent to peers whenever the event is called locally via the normal event "
"invocation syntax. When auto-publishing events, local event handlers for "
"the event are called in addition to sending the event to any subscribed "
"peers."
msgstr ""

#: ../../frameworks/broker.rst:274
msgid "events-connector.zeek"
msgstr ""

#: ../../frameworks/broker.rst:280
msgid ""
"Note that the subscription model is prefix-based, meaning that if you "
"subscribe to the \"zeek/events\" topic prefix you would receive events "
"that are published to topic names  \"zeek/events/foo\" and "
"\"zeek/events/bar\" but not \"zeek/misc\"."
msgstr ""

#: ../../frameworks/broker.rst:285
msgid "Remote Logging"
msgstr ""

#: ../../frameworks/broker.rst:287
msgid "testlog.zeek"
msgstr ""

#: ../../frameworks/broker.rst:293
msgid ""
"To toggle remote logs, redef :zeek:see:`Log::enable_remote_logging`. Use "
"the :zeek:see:`Broker::subscribe` function to advertise interest in logs "
"written by peers.  The topic names that Zeek uses are determined by "
":zeek:see:`Broker::log_topic`."
msgstr ""

#: ../../frameworks/broker.rst:298
msgid "logs-listener.zeek"
msgstr ""

#: ../../frameworks/broker.rst:304
msgid "logs-connector.zeek"
msgstr ""

#: ../../frameworks/broker.rst:310
msgid ""
"Note that logging events are only raised locally on the node that "
"performs the :zeek:see:`Log::write` and not automatically published to "
"peers."
msgstr ""

#: ../../frameworks/broker.rst:316
msgid "Distributed Data Stores"
msgstr ""

#: ../../frameworks/broker.rst:318
msgid ""
"See :doc:`/scripts/base/frameworks/broker/store.zeek` for an overview of "
"the Broker data store API."
msgstr ""

#: ../../frameworks/broker.rst:321
msgid ""
"There are two flavors of key-value data store interfaces: master and "
"clone."
msgstr ""

#: ../../frameworks/broker.rst:323
msgid ""
"A master data store can be cloned from remote peers which may then "
"perform lightweight, local queries against the clone, which automatically"
" stays synchronized with the master store.  Clones cannot modify their "
"content directly, instead they send modifications to the centralized "
"master store which applies them and then broadcasts them to all clones."
msgstr ""

#: ../../frameworks/broker.rst:330
msgid ""
"Master stores get to choose what type of storage backend to use.  E.g. "
"In-memory versus SQLite for persistence."
msgstr ""

#: ../../frameworks/broker.rst:333
msgid ""
"Data stores also support expiration on a per-key basis using an amount of"
" time relative to the entry's last modification time."
msgstr ""

#: ../../frameworks/broker.rst:336
msgid "stores-listener.zeek"
msgstr ""

#: ../../frameworks/broker.rst:342
msgid "stores-connector.zeek"
msgstr ""

#: ../../frameworks/broker.rst:348
msgid ""
"Note that all data store queries must be made within Zeek's asynchronous "
"``when`` statements and must specify a timeout block."
msgstr ""

#: ../../frameworks/broker.rst:352
msgid "Cluster Framework Examples"
msgstr ""

#: ../../frameworks/broker.rst:354
msgid ""
"This section contains a few brief examples of how various communication "
"patterns one might use when developing Zeek scripts that are to operate "
"in the context of a cluster."
msgstr ""

#: ../../frameworks/broker.rst:359
msgid "A Reminder About Events and Module Namespaces"
msgstr ""

#: ../../frameworks/broker.rst:361
msgid ""
"For simplicity, the following examples do not use any modules/namespaces."
" If you choose to use them within your own code, it's important to "
"remember that the ``event`` and ``schedule`` dispatching statements "
"should always use the fully-qualified event name."
msgstr ""

#: ../../frameworks/broker.rst:366
msgid "For example, this will likely not work as expected:"
msgstr ""

#: ../../frameworks/broker.rst:387
msgid ""
"This code runs without errors, however, the local ``my_event`` handler "
"will never be called and also not any remote handlers either, even if "
":zeek:see:`Broker::auto_publish` was used elsewhere for it.  Instead, at "
"minimum you would need change the ``zeek_init()`` handler:"
msgstr ""

#: ../../frameworks/broker.rst:400
msgid ""
"Though, an easy rule of thumb to remember would be to always use the "
"explicit module namespace scoping and you can't go wrong:"
msgstr ""

#: ../../frameworks/broker.rst:422
msgid ""
"Note that other identifiers in Zeek do not have this inconsistency "
"related to module namespacing, it's just events that require "
"explicitness."
msgstr ""

#: ../../frameworks/broker.rst:427
msgid "Manager Sending Events To Workers"
msgstr ""

#: ../../frameworks/broker.rst:429
msgid ""
"This is fairly straightforward, we just need a topic name which we know "
"all workers are subscribed combined with the event we want to send them."
msgstr ""

#: ../../frameworks/broker.rst:469
msgid "Worker Sending Events To Manager"
msgstr ""

#: ../../frameworks/broker.rst:471
msgid ""
"This should look almost identical to the previous case of sending an "
"event from the manager to workers, except it simply changes the topic "
"name to one which the manager is subscribed."
msgstr ""

#: ../../frameworks/broker.rst:489
msgid "Worker Sending Events To All Workers"
msgstr ""

#: ../../frameworks/broker.rst:491
msgid ""
"Since workers are not directly connected to each other in the cluster "
"topology, this type of communication is a bit different than what we did "
"before since we have to manually relay the event via some node that *is* "
"connected to all workers.  The manager or a proxy satisfies that "
"requirement:"
msgstr ""

#: ../../frameworks/broker.rst:528
msgid "Worker Distributing Events Uniformly Across Proxies"
msgstr ""

#: ../../frameworks/broker.rst:530
msgid ""
"If you want to offload some data/work from a worker to your proxies, we "
"can make use of a `Highest Random Weight (HRW) hashing "
"<https://en.wikipedia.org/wiki/Rendezvous_hashing>`_ distribution "
"strategy to uniformly map an arbitrary key space across all available "
"proxies."
msgstr ""

#: ../../frameworks/broker.rst:558
msgid "Broker-backed Zeek Tables for Data Synchronization and Persistence"
msgstr ""

#: ../../frameworks/broker.rst:560
msgid ""
"Starting with Zeek 3.2, it is possible to \"bind\" a Zeek table to a "
"backing Broker store. Changes to the Zeek table are sent to the Broker "
"store. Similarly, changes of the Broker store are applied to the Zeek "
"table."
msgstr ""

#: ../../frameworks/broker.rst:566
msgid ""
"This feature is experimental and can change in future versions without "
"prior deprecation/backwards compatibility."
msgstr ""

#: ../../frameworks/broker.rst:569
msgid ""
"This feature allows easy distribution of table contents across a cluster."
" It also offers persistence for tables (when using a persistent Broker "
"store backend like SQLite)."
msgstr ""

#: ../../frameworks/broker.rst:573
msgid ""
"To give a short example, to distribute a table over a cluster you can use"
" the :zeek:attr:`&backend` attribute."
msgstr ""

#: ../../frameworks/broker.rst:580
msgid ""
"The :zeek:attr:`&backend` attribute creates a master data store on the "
"manager and a clone data store on all other node on the cluster. This in "
"essence means that the table exists twice in each Zeek process. One copy "
"of the table is contained in a Broker data store (either a master or a "
"clone depending on the node), which data store distributes the data "
"across the cluster---and, depending on the backend, might also make the "
"data persistent. Since Broker data stores are only accessible via "
"asynchronous operations, and accessing them might not always be "
"immediate, a second copy of the table, which is immediately accessible, "
"is held inside the Zeek core. This is the copy that you see and interact "
"with on the Zeek side."
msgstr ""

#: ../../frameworks/broker.rst:593
msgid "Tips for Porting Bro 2.5 and earlier"
msgstr ""

#: ../../frameworks/broker.rst:595
msgid ""
"Review and use the points below as a guide to port your own scripts to "
"Bro 2.6 or later version of Zeek, which uses the new cluster and Broker "
"communication framework."
msgstr ""

#: ../../frameworks/broker.rst:600
msgid "General Porting Tips"
msgstr ""

#: ../../frameworks/broker.rst:602
msgid ""
"``@load policy/frameworks/communication/listen`` and ``@load "
"base/frameworks/communication`` indicates use of the old communication "
"framework, consider porting to ``@load base/frameworks/broker`` and using"
" the Broker API: :doc:`/scripts/base/frameworks/broker/main.zeek`"
msgstr ""

#: ../../frameworks/broker.rst:608
msgid ""
"The ``&synchronized`` and ``&persistent`` attributes are deprecated, "
"consider using `Data Stores`_ instead."
msgstr ""

#: ../../frameworks/broker.rst:611
msgid ""
"Usages of the old communications system features are all deprecated, "
"however, they also do not work in the default Zeek configuration unless "
"you manually take action to set up the old communication system. To aid "
"in porting, such usages will default to raising a fatal error unless you "
"explicitly acknowledge that such usages of the old system are ok.  Set "
"the ``old_comm_usage_is_ok`` flag in this case."
msgstr ""

#: ../../frameworks/broker.rst:618
msgid ""
"Instead of using e.g. ``Cluster::manager2worker_events`` (and all "
"permutations for every node type), what you'd now use is either "
":zeek:see:`Broker::publish` or :zeek:see:`Broker::auto_publish` with "
"either the topic associated with a specific node or class of nodes, like "
":zeek:see:`Cluster::node_topic` or :zeek:see:`Cluster::worker_topic`."
msgstr ""

#: ../../frameworks/broker.rst:625
msgid "Instead of using the ``send_id`` BIF, use :zeek:see:`Broker::publish_id`."
msgstr ""

#: ../../frameworks/broker.rst:627
msgid ""
"Use :zeek:see:`terminate` instead of ``terminate_communication``. The "
"latter refers to the old communication system and no longer affects the "
"new Broker-based system."
msgstr ""

#: ../../frameworks/broker.rst:631
msgid ""
"For replacing ``remote_connection_established`` and "
"``remote_connection_closed``, consider :zeek:see:`Broker::peer_added` or "
":zeek:see:`Broker::peer_lost`.  There's also :zeek:see:`Cluster::node_up`"
" and :zeek:see:`Cluster::node_down`."
msgstr ""

#: ../../frameworks/broker.rst:636
msgid ""
"The general toplogogy of a cluster has changed: namely proxy nodes do not"
" connect to each other anymore."
msgstr ""

#: ../../frameworks/broker.rst:640
msgid "Notable / Specific Script API Changes"
msgstr ""

#: ../../frameworks/broker.rst:642
msgid ""
":zeek:see:`Software::tracked` is now partitioned among proxy nodes "
"instead of synchronized in its entirety to all nodes."
msgstr ""

#: ../../frameworks/broker.rst:645
msgid ""
"``Known::known_hosts`` is renamed to :zeek:see:`Known::host_store` and "
"implemented via the new Broker data store interface."
msgstr ""

#: ../../frameworks/broker.rst:648
msgid ""
"``Known::known_services`` is renamed to :zeek:see:`Known::service_store` "
"and implemented via the new Broker data store interface."
msgstr ""

#: ../../frameworks/broker.rst:651
msgid ""
"``Known::certs`` is renamed to :zeek:see:`Known::cert_store` and "
"implemented via the new Broker data store interface."
msgstr ""

