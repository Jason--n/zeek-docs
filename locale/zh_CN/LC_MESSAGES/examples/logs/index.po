# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, The Zeek Project
# This file is distributed under the same license as the Zeek package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Zeek source\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-28 21:33+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../examples/logs/index.rst:8
msgid "Logging"
msgstr ""

#: ../../examples/logs/index.rst:10
msgid ""
"Once Zeek has been deployed in an environment and monitoring live "
"traffic, it will, in its default configuration, begin to produce human-"
"readable ASCII logs.  Each log file, produced by Zeek's :ref:`framework-"
"logging`, is populated with organized, mostly connection-oriented data.  "
"As the standard log files are simple ASCII data, working with the data "
"contained in them can be done from a command line terminal once you have "
"been familiarized with the types of data that can be found in each file. "
"In the following, we work through the logs general structure and then "
"examine some standard ways of working with them."
msgstr ""

#: ../../examples/logs/index.rst:23
msgid "Working with Log Files"
msgstr ""

#: ../../examples/logs/index.rst:25
msgid ""
"Generally, all of Zeek's log files are produced by a corresponding script"
" that defines their individual structure. However, as each log file flows"
" through the Logging Framework, they share a set of structural "
"similarities. Without breaking into the scripting aspect of Zeek here, a "
"bird's eye view of how the log files are produced progresses as follows."
"  The script's author defines the kinds of data, such as the originating "
"IP address or the duration of a connection, which will make up the fields"
" (i.e., columns) of the log file.  The author then decides what network "
"activity should generate a single log file entry (i.e., one line). For "
"example, this could be a connection having been completed or an HTTP "
"``GET`` request being issued by an originator. When these behaviors are "
"observed during operation, the data is passed to the Logging Framework "
"which adds the entry to the appropriate log file."
msgstr ""

#: ../../examples/logs/index.rst:40
msgid ""
"As the fields of the log entries can be further customized by the user, "
"the Logging Framework makes use of a header block to ensure that it "
"remains self-describing. Here's the first few lines of a ``conn.log``."
msgstr ""

#: ../../examples/logs/index.rst:60
msgid ""
"As you can see, the header consists of lines prefixed by ``#`` and "
"includes information such as what separators are being used for various "
"types of data, what an empty field looks like and what an unset field "
"looks like.  In this example, the default TAB separator is being used as "
"the delimiter between fields (``\\x09`` is the tab character in hex).  It"
" also lists the comma as the separator for set data, the string "
"``(empty)`` as the indicator for an empty field and the ``-`` character "
"as the indicator for a field that hasn't been set. The timestamp for when"
" the file was created is included under ``#open``. The header then goes "
"on to detail the fields being listed in the file and the data types of "
"those fields, in ``#fields`` and ``#types``, respectively. These two "
"entries are often the two most significant points of interest as they "
"detail not only the field names but the data types used. When navigating "
"through the different log files with tools like ``sed``, ``awk``, or "
"``grep``, having the field definitions readily available saves the user "
"some mental leg work. The field names are also a key resource for using "
"the :ref:`zeek-cut <zeek-cut>` utility included with Zeek, see below."
msgstr ""

#: ../../examples/logs/index.rst:79
msgid ""
"Next to the header follows the main content. In this example we see 7 "
"connections with their key properties, such as originator and responder "
"IP addresses (note how Zeek transparently handles both IPv4 and IPv6), "
"transport-layer ports, application-layer services ( - the ``service`` "
"field is filled in as Zeek determines a specific protocol to be in use, "
"independent of the connection's ports), payload size, and more. See "
":zeek:type:`Conn::Info` for a description of all fields."
msgstr ""

#: ../../examples/logs/index.rst:87
msgid ""
"In addition to ``conn.log``, Zeek generates many further logs by default,"
" including:"
msgstr ""

#: ../../examples/logs/index.rst:91
msgid "``dpd.log``"
msgstr ""

#: ../../examples/logs/index.rst:91
msgid "A summary of protocols encountered on non-standard ports."
msgstr ""

#: ../../examples/logs/index.rst:94
msgid "``dns.log``"
msgstr ""

#: ../../examples/logs/index.rst:94
msgid "All DNS activity."
msgstr ""

#: ../../examples/logs/index.rst:97
msgid "``ftp.log``"
msgstr ""

#: ../../examples/logs/index.rst:97
msgid "A log of FTP session-level activity."
msgstr ""

#: ../../examples/logs/index.rst:102
msgid "``files.log``"
msgstr ""

#: ../../examples/logs/index.rst:100
msgid ""
"Summaries of files transferred over the network. This information is "
"aggregated from different protocols, including HTTP, FTP, and SMTP."
msgstr ""

#: ../../examples/logs/index.rst:105
msgid "``http.log``"
msgstr ""

#: ../../examples/logs/index.rst:105
msgid "A summary of all HTTP requests with their replies."
msgstr ""

#: ../../examples/logs/index.rst:108
msgid "``known_certs.log``"
msgstr ""

#: ../../examples/logs/index.rst:108
msgid "SSL certificates seen in use."
msgstr ""

#: ../../examples/logs/index.rst:111
msgid "``smtp.log``"
msgstr ""

#: ../../examples/logs/index.rst:111
msgid "A summary of SMTP activity."
msgstr ""

#: ../../examples/logs/index.rst:114
msgid "``ssl.log``"
msgstr ""

#: ../../examples/logs/index.rst:114
msgid "A record of SSL sessions, including certificates being used."
msgstr ""

#: ../../examples/logs/index.rst:121
msgid "``weird.log``"
msgstr ""

#: ../../examples/logs/index.rst:117
msgid ""
"A log of unexpected protocol-level activity. Whenever Zeek's protocol "
"analysis encounters a situation it would not expect (e.g., an RFC "
"violation) it logs it in this file. Note that in practice, real-world "
"networks tend to exhibit a large number of such \"crud\" that is usually "
"not worth following up on."
msgstr ""

#: ../../examples/logs/index.rst:123
msgid ""
"As you can see, some log files are specific to a particular protocol, "
"while others aggregate information across different types of activity. "
"For a complete list of log files and a description of its purpose, see "
":doc:`Log Files </script-reference/log-files>`."
msgstr ""

#: ../../examples/logs/index.rst:133
msgid "Using ``zeek-cut``"
msgstr ""

#: ../../examples/logs/index.rst:135
msgid ""
"The ``zeek-cut`` utility can be used in place of other tools to build "
"terminal commands that remain flexible and accurate independent of "
"possible changes to the log file itself.  It accomplishes this by parsing"
" the header in each file and allowing the user to refer to the specific "
"columnar data available (in contrast to tools like ``awk`` that require "
"the user to refer to fields referenced by their position). For example, "
"the following command extracts just the given columns from a "
"``conn.log``:"
msgstr ""

#: ../../examples/logs/index.rst:159
msgid "The corresponding ``awk`` command will look like this:"
msgstr ""

#: ../../examples/logs/index.rst:176
msgid ""
"While the output is similar, the advantages to using zeek-cut over "
"``awk`` lay in that, while ``awk`` is flexible and powerful, ``zeek-cut``"
" was specifically designed to work with Zeek's log files.  Firstly, the "
"``zeek-cut`` output includes only the log file entries, while the ``awk``"
" solution needs to skip the header manually. Secondly, since ``zeek-cut``"
" uses the field descriptors to identify and extract data, it allows for "
"flexibility independent of the format and contents of the log file.  It's"
" not uncommon for a Zeek configuration to add extra fields to various log"
" files as required by the environment.  In this case, the fields in the "
"``awk`` command would have to be altered to compensate for the new "
"position whereas the ``zeek-cut`` output would not change."
msgstr ""

#: ../../examples/logs/index.rst:191
msgid ""
"The sequence of field names given to ``zeek-cut`` determines the output "
"order, which means you can also use ``zeek-cut`` to reorder fields. That "
"can be helpful when piping into, e.g., ``sort``."
msgstr ""

#: ../../examples/logs/index.rst:195
msgid ""
"As you may have noticed, the command for ``zeek-cut`` uses the output "
"redirection through the ``cat`` command and ``|`` operator.  Whereas "
"tools like ``awk`` allow you to indicate the log file as a command line "
"option, zeek-cut only takes input through redirection such as ``|`` and "
"``<``.  There are a couple of ways to direct log file data into ``zeek-"
"cut``, each dependent upon the type of log file you're processing.  A "
"caveat of its use, however, is that all of the header lines must be "
"present."
msgstr ""

#: ../../examples/logs/index.rst:206
msgid ""
"``zeek-cut`` provides an option ``-c`` to include a corresponding format "
"header into the output, which allows to chain multiple ``zeek-cut`` "
"instances or perform further post-processing that evaluates the header "
"information."
msgstr ""

#: ../../examples/logs/index.rst:211
msgid ""
"In its default setup, Zeek will rotate log files on an hourly basis, "
"moving the current log file into a directory with format ``YYYY-MM-DD`` "
"and gzip compressing the file with a file format that includes the log "
"file type and time range of the file.  In the case of processing a "
"compressed log file you simply adjust your command line tools to use the "
"complementary ``z*`` versions of commands such as ``cat`` (``zcat``) or "
"``grep`` (``zgrep``)."
msgstr ""

#: ../../examples/logs/index.rst:220
msgid "Working with Timestamps"
msgstr ""

#: ../../examples/logs/index.rst:222
msgid ""
"``zeek-cut`` accepts the flag ``-d`` to convert the epoch time values in "
"the log files to human-readable format.  The following command includes "
"the human readable time stamp, the unique identifier, the HTTP ``Host``, "
"and HTTP ``URI`` as extracted from the ``http.log`` file:"
msgstr ""

#: ../../examples/logs/index.rst:238
msgid ""
"Often times log files from multiple sources are stored in UTC time to "
"allow easy correlation.  Converting the timestamp from a log file to UTC "
"can be accomplished with the ``-u`` option:"
msgstr ""

#: ../../examples/logs/index.rst:252
#, python-format
msgid ""
"The default time format when using the ``-d`` or ``-u`` is the "
"``strftime`` format string ``%Y-%m-%dT%H:%M:%S%z`` which results in a "
"string with year, month, day of month, followed by hour, minutes, seconds"
" and the timezone offset.  The default format can be altered by using the"
" ``-D`` and ``-U`` flags, using the standard ``strftime`` syntax. For "
"example, to format the timestamp in the US-typical \"Middle Endian\" you "
"could use a format string of: ``%d-%m-%YT%H:%M:%S%z``"
msgstr ""

#: ../../examples/logs/index.rst:270
msgid "See ``man strftime`` for more options for the format string."
msgstr ""

#: ../../examples/logs/index.rst:273
msgid "Using UIDs"
msgstr ""

#: ../../examples/logs/index.rst:275
msgid ""
"While Zeek can do signature-based analysis, its primary focus is on "
"behavioral detection which alters the practice of log review from "
"\"reactionary review\" to a process a little more akin to a hunting trip."
"  A common progression of review includes correlating a session across "
"multiple log files.  As a connection is processed by Zeek, a unique "
"identifier is assigned to each session.  This unique identifier is "
"generally included in any log file entry associated with that connection "
"and can be used to cross-reference different log files."
msgstr ""

#: ../../examples/logs/index.rst:284
msgid ""
"A simple example would be to cross-reference a UID seen in a ``conn.log``"
" file.  Here, we're looking for the connection with the largest number of"
" bytes from the responder by redirecting the output for ``cat conn.log`` "
"into zeek-cut to extract the UID and the resp_bytes, then sorting that "
"output by the resp_bytes field."
msgstr ""

#: ../../examples/logs/index.rst:299
msgid ""
"Taking the UID of the first of the top responses, we can now "
"crossreference that with the UIDs in the ``http.log`` file."
msgstr ""

#: ../../examples/logs/index.rst:307
msgid ""
"As you can see there are two HTTP ``GET`` requests within the session "
"that Zeek identified and logged.  Given that HTTP is a stream protocol, "
"it can have multiple ``GET``/``POST``/etc requests in a stream and Zeek "
"is able to extract and track that information for you, giving you an in-"
"depth and structured view into HTTP traffic on your network."
msgstr ""

